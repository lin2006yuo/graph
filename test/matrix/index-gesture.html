<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Matrix - Gesture</title>
    <script src="../glMatrix.js"></script>
    <script src="../size.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
  </head>
  <style>
    body,
    html {
      margin: 0;
      padding: 0;
    }
    #app {
      padding: 10px;
    }
    .operator {
      margin-left: 20px;
    }
    .operator h4 {
      margin-right: 8px;
    }
    .flex {
      display: flex;
    }
    .flex-align-center {
      align-items: center;
    }
    .flex-justify-center {
      justify-content: center;
    }
    .range-slider {
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      width: 10rem;
      height: 0.25rem;
      outline: none;
      border-radius: 0.25rem;
      background-color: #000;
    }
    .range-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 1rem;
      height: 1rem;
      background-color: #fff;
      border: 0.25rem solid #000;
      border-radius: 1rem;
      cursor: pointer;
    }
  </style>
  <body>
    <div id="app">
      <div>
        <div class="flex">
          <canvas id="canvas"></canvas>
          <div class="operator">
            <div class="flex flex-align-center">
              <h4>x</h4>
              <input @input="handleXChange" type="range" min="0" max="100" value="0" :value="operateX / canvasWidth * 100" class="range-slider" />
            </div>
            <div class="flex flex-align-center">
              <h4>y</h4>
              <input @input="handleYChange" type="range" min="0" max="100" value="0" :value="operateY / canvasWidth * 100" class="range-slider" />
            </div>
            <div class="flex flex-align-center">
              <h4>rad</h4>
              <input @input="handleRadChange" type="range" min="0" max="100" value="0" class="range-slider" />
            </div>
            <div class="flex flex-align-center">
              <h4>scaleX</h4>
              <input @input="handleScaleXChange" type="range" min="0" max="100" :value="(operateScaleX - 1) / 4 * 100" class="range-slider" />
            </div>
            <div class="flex flex-align-center">
              <h4>scaleY</h4>
              <input @input="handleScaleYChange" type="range" min="0" max="100" :value="(operateScaleY - 1) / 4 * 100" class="range-slider" />
            </div>
            <div class="flex flex-align-center">
              <h4>originX</h4>
              <input type="number" @input="handleOriginXChange" :value="operateOriginX" />
            </div>
            <div class="flex flex-align-center">
              <h4>originY</h4>
              <input type="number" @input="handleOriginYChange" :value="operateOriginY" />
            </div>
            <div class="flex flex-align-center">
              <button @click="handleOriginCenter">基于中心旋转</button>
            </div>
          </div>
        </div>
        <div>
          <h4>basic</h4>
          <div><span>mouse</span><span>x: {{mouse.x}}</span><span>y: {{mouse.y}}</span></div>
          <h4>ball</h4>
          <div><span>x: </span> <span v-if="ball">{{ball.x}}</span></div>
          <div><span>y: </span> <span v-if="ball">{{ball.y}}</span></div>
          <div><span>rad: </span><span v-if="ball">{{ball.rad}} (angle: {{angle}})</span></div>
          <div><span>scaleX: </span><span v-if="ball">{{ball.scaleX}}</span></div>
          <div><span>scaleY: </span><span v-if="ball">{{ball.scaleY}}</span></div>
          <div><span>originX: </span><span v-if="ball">{{ball.originX}}</span></div>
          <div><span>originY: </span><span v-if="ball">{{ball.originY}}</span></div>
        </div>
      </div>
    </div>

    <script>
      function distance(x1, y1, x2, y2) {
        return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2))
      }
      class Ball {
        constructor(ctx, opt) {
          const { x = 0, y = 0, radius = 10, color = "red", rad = 0, scaleX = 1, scaleY = 1, originX = 0, originY = 0 } = opt
          this.ctx = ctx
          this.radius = radius
          this.lineWidth = 1
          this.color = color

          this.x = x
          this.y = y
          this.rad = rad
          this.scaleX = scaleX
          this.scaleY = scaleY
          this.originX = originX
          this.originY = originY

          this.matrix = glMatrix.mat2d.create()
          this.transform({ x, y, rad, scaleX, scaleY, originX, originY })
        }

        transform(params) {
          const { x = this.x, y = this.y, rad = this.rad, scaleX = this.scaleX, scaleY = this.scaleY, originX = this.originX, originY = this.originY } = params
          const resultMatrix = glMatrix.mat2d.create()

          // 改变变换原点中心
          const moveOriginMatrix = glMatrix.mat2d.translate([], glMatrix.mat2d.create(), [originX, originY])

          // 平移矩阵
          const translateMatrix = glMatrix.mat2d.translate([], glMatrix.mat2d.create(), [x, y])

          // 旋转矩阵
          const rotateMatrix = glMatrix.mat2d.rotate([], glMatrix.mat2d.create(), rad)

          // 缩放矩阵
          const scaleMatrix = glMatrix.mat2d.scale([], glMatrix.mat2d.create(), [scaleX, scaleY])

          // 计算最终矩阵
          // glMatrix.mat2d.multiply(resultMatrix, rotateMatrix, translateMatrix) // 先旋转再平移
          glMatrix.mat2d.multiply(resultMatrix, translateMatrix, rotateMatrix) // 先平移再旋转
          glMatrix.mat2d.multiply(resultMatrix, resultMatrix, scaleMatrix)
          glMatrix.mat2d.multiply(resultMatrix, resultMatrix, moveOriginMatrix)

          this.x = x
          this.y = y
          this.rad = rad
          this.scaleX = scaleX
          this.scaleY = scaleY
          this.originX = originX
          this.originY = originY
          this.matrix = resultMatrix
        }

        /**
         * 判断是否在右下角顶点内
         * */
        isOver(point) {
          const { x, y } = point
          const vec4 = glMatrix.vec2.transformMat2d([], [50, 50], this.matrix)
          const br = { x: 0, y: 0 }
          br.x = vec4[0] - this.originX
          br.y = vec4[1] - this.originY
          return distance(x, y, br.x, br.y) < this.radius + this.lineWidth
        }

        get originPos() {
          const vec_origin = glMatrix.vec2.transformMat2d([], [-this.originX, -this.originY], this.matrix)
          return { x: vec_origin[0] - this.originX, y: vec_origin[1] - this.originY }
        }

        draw() {
          // 画一个矩形
          const vec1 = glMatrix.vec2.transformMat2d([], [0, 0], this.matrix)
          const vec2 = glMatrix.vec2.transformMat2d([], [50, 0], this.matrix)
          const vec3 = glMatrix.vec2.transformMat2d([], [50, 50], this.matrix)
          const vec4 = glMatrix.vec2.transformMat2d([], [0, 50], this.matrix)

          this.ctx.save()
          this.ctx.lineWidth = this.lineWidth

          // 绘制4个角
          this.ctx.fillStyle = this.color
          this.ctx.beginPath()
          this.ctx.arc(vec1[0] - this.originX, vec1[1] - this.originY, this.radius, 0, 2 * Math.PI)
          this.ctx.fill()
          this.ctx.closePath()

          this.ctx.beginPath()
          this.ctx.arc(vec2[0] - this.originX, vec2[1] - this.originY, this.radius, 0, 2 * Math.PI)
          this.ctx.fill()
          this.ctx.closePath()

          this.ctx.beginPath()
          this.ctx.arc(vec3[0] - this.originX, vec3[1] - this.originY, this.radius, 0, 2 * Math.PI)
          this.ctx.fill()
          this.ctx.closePath()

          this.ctx.beginPath()
          this.ctx.arc(vec4[0] - this.originX, vec4[1] - this.originY, this.radius, 0, 2 * Math.PI)
          this.ctx.fill()
          this.ctx.closePath()

          // 绘制原点
          this.ctx.beginPath()
          this.ctx.fillStyle = "black"
          this.ctx.arc(this.originPos.x, this.originPos.y, 5, 0, 2 * Math.PI)
          this.ctx.fill()
          this.ctx.closePath()

          this.ctx.restore()
        }
      }

      let vm = new Vue({
        el: "#app",
        data() {
          return {
            canvas: null,
            canvasWidth: 0,
            canvasHeight: 0,
            ctx: null,

            operateX: 500,
            operateY: 100,
            operateRad: 0,
            operateScaleX: 1,
            operateScaleY: 1,
            operateOriginX: 0,
            operateOriginY: 0,

            ball: null,
            mouse: { x: 0, y: 0 },

            isMouseDownBR: false,
            BRLastOffset: { x: 0, y: 0 }
          }
        },
        computed: {
          angle() {
            return (360 * this.ball.rad) / (2 * Math.PI)
          }
        },
        mounted() {
          const {
            canvas,
            width: canvasWidth,
            height: canvasHeight
          } = new KSize("canvas", {
            width: 500,
            height: 500
          })
          this.canvas = canvas
          this.canvasWidth = canvasWidth
          this.canvasHeight = canvasHeight

          this.ctx = canvas.getContext("2d")
          this.ball = new Ball(this.ctx, { x: this.operateX, y: this.operateY })

          canvas.addEventListener("mousedown", this.handleMouseDown)
          window.addEventListener("mousemove", this.handleMouseMove)
          window.addEventListener("mouseup", this.handleMouseUp)

          this.render()
        },
        beforeDestroy() {
          canvas.removeEventListener("mousedown", this.handleMouseDown)
          window.removeEventListener("mousemove", this.handleMouseMove)
          window.removeEventListener("mouseup", this.handleMouseUp)
        },
        methods: {
          render() {
            this.ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight)
            this.ball.draw()
            requestAnimationFrame(this.render)
          },
          handleMouseDown(e) {
            const isOverBR = this.isOverBR(e)
            if (isOverBR) {
              this.isMouseDownBR = true
              this.BRLastOffset.x = this.mouse.x
              this.BRLastOffset.y = this.mouse.y
            }
          },
          handleMouseMove(e) {
            const isOverBR = this.isOverBR(e)

            if (isOverBR) {
              this.canvas.style.cursor = "se-resize"
            } else {
              this.canvas.style.cursor = ""
            }

            // 缩放操作 
            if (this.isMouseDownBR) {
              const BRCurrentOffset = { x: this.mouse.x, y: this.mouse.y }
              const scaleRatioX = (BRCurrentOffset.x - this.ball.originPos.x) / (this.BRLastOffset.x - this.ball.originPos.x)
              const scaleRatioY = (BRCurrentOffset.y - this.ball.originPos.y) / (this.BRLastOffset.y - this.ball.originPos.y)
              this.ball.transform({
                scaleX: scaleRatioX,
                scaleY: scaleRatioY
              })
              // const offset = [BRCurrentOffset.x - this.BRLastOffset.x, BRCurrentOffset.y - this.BRLastOffset.y]
              // const scaleRatio = { x: offset[0] /, y: 1 }
              // this.BRLastOffset.x = BRCurrentOffset.x
              // this.BRLastOffset.y = BRCurrentOffset.y
            }
          },
          handleMouseUp() {
            this.isMouseDownBR = false
          },
          isOverBR(e) {
            this.mouse.x = (e.pageX - this.canvas.offsetLeft) * 2 // 2 is canvas hidpi ratio
            this.mouse.y = (e.pageY - this.canvas.offsetTop) * 2
            return this.ball.isOver(this.mouse)
          },

          handleXChange(e) {
            const percent = e.currentTarget.value / 100
            this.operateX = this.canvasWidth * percent

            this.ball.transform({ x: this.operateX })
          },
          handleYChange(e) {
            const percent = e.currentTarget.value / 100
            this.operateY = this.canvasWidth * percent

            this.ball.transform({ y: this.operateY })
          },
          handleRadChange(e) {
            const percent = e.currentTarget.value / 100
            this.operateRad = 2 * Math.PI * percent

            this.ball.transform({ rad: this.operateRad })
          },
          handleScaleXChange(e) {
            const percent = e.currentTarget.value / 100
            this.operateScaleX = percent * 4 + 1 // 1 ~ 5

            this.ball.transform({ scaleX: this.operateScaleX })
          },
          handleScaleYChange(e) {
            const percent = e.currentTarget.value / 100
            this.operateScaleY = percent * 4 + 1 // 1 ~ 5

            this.ball.transform({ scaleY: this.operateScaleY })
          },
          handleOriginXChange(e) {
            const v = Number(e.currentTarget.value)
            this.operateOriginX = v
            this.ball.transform({ originX: v })
          },
          handleOriginYChange(e) {
            const v = Number(e.currentTarget.value)
            this.operateOriginY = v
            this.ball.transform({ originY: v })
          },
          handleOriginCenter() {
            this.operateOriginX = -25
            this.operateOriginY = -25
            this.ball.transform({ originX: this.operateOriginX, originY: this.operateOriginY })
          }
        }
      })
    </script>
  </body>
</html>
