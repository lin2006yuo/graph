<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script src="../glMatrix.js"></script>
    <script src="../size.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
  </head>
  <style>
    body,
    html {
      margin: 0;
      padding: 0;
    }
    #app {
      padding: 10px;
    }
    .operator {
      margin-left: 20px;
    }
    .operator h4 {
      margin-right: 8px;
    }
    .flex {
      display: flex;
    }
    .flex-align-center {
      align-items: center;
    }
    .flex-justify-center {
      justify-content: center;
    }
    .range-slider {
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      width: 10rem;
      height: 0.25rem;
      outline: none;
      border-radius: 0.25rem;
      background-color: #000;
    }
    .range-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 1rem;
      height: 1rem;
      background-color: #fff;
      border: 0.25rem solid #000;
      border-radius: 1rem;
      cursor: pointer;
    }
  </style>
  <body>
    <div id="app">
      <div>
        <div class="flex">
          <canvas id="canvas"></canvas>
          <div class="operator">
            <div class="flex flex-align-center">
              <h4>x</h4>
              <input @input="handleXChange" type="range" min="0" max="100" value="0" :value="operateX / canvasWidth * 100" class="range-slider" />
            </div>
            <div class="flex flex-align-center">
              <h4>y</h4>
              <input @input="handleYChange" type="range" min="0" max="100" value="0" :value="operateY / canvasWidth * 100" class="range-slider" />
            </div>
            <div class="flex flex-align-center">
              <h4>rad</h4>
              <input @input="handleRadChange" type="range" min="0" max="100" value="0" class="range-slider" />
            </div>
            <div class="flex flex-align-center">
              <h4>scaleX</h4>
              <input @input="handleScaleXChange" type="range" min="0" max="100" :value="(operateScaleX - 1) / 4 * 100" class="range-slider" />
            </div>
            <div class="flex flex-align-center">
              <h4>scaleY</h4>
              <input @input="handleScaleYChange" type="range" min="0" max="100" :value="(operateScaleY - 1) / 4 * 100" class="range-slider" />
            </div>
          </div>
        </div>
        <div>
          <h4>basic</h4>
          <!-- <div><span>oper: </span> <span>{{operateXPercent}}</span></div> -->
          <h4>ball</h4>
          <div><span>x: </span> <span v-if="ball">{{ball.x}}</span></div>
          <div><span>y: </span> <span v-if="ball">{{ball.y}}</span></div>
          <div><span>rad: </span><span v-if="ball">{{ball.rad}} (angle: {{angle}})</span></div>
          <div><span>scaleX: </span><span v-if="ball">{{ball.scaleX}}</span></div>
          <div><span>scaleY: </span><span v-if="ball">{{ball.scaleY}}</span></div>
        </div>
      </div>
    </div>

    <script>
      class Ball {
        constructor(ctx, opt) {
          const { x = 0, y = 0, radius = 10, color = "red", rad = 0, scaleX = 1, scaleY = 1 } = opt
          this.ctx = ctx
          this.radius = radius
          this.color = color

          this.x = x
          this.y = y
          this.rad = rad
          this.scaleX = scaleX
          this.scaleY = scaleY

          this.matrix = glMatrix.mat2d.create()
          this.transform({ x, y, rad, scaleX, scaleY })
        }

        transform(params) {
          const { x = this.x, y = this.y, rad = this.rad, scaleX = this.scaleX, scaleY = this.scaleY } = params
          const resultMatrix = glMatrix.mat2d.create()

          // 平移矩阵
          const translateMatrix = glMatrix.mat2d.translate([], glMatrix.mat2d.create(), [x, y])

          // 旋转矩阵
          const rotateMatrix = glMatrix.mat2d.rotate([], glMatrix.mat2d.create(), rad)

          // 缩放矩阵
          const scaleMatrix = glMatrix.mat2d.scale([], glMatrix.mat2d.create(), [scaleX, scaleY])

          // 计算最终矩阵
          // glMatrix.mat2d.multiply(resultMatrix, rotateMatrix, translateMatrix) // 先旋转再平移
          glMatrix.mat2d.multiply(resultMatrix, translateMatrix, rotateMatrix) // 先平移再旋转
          glMatrix.mat2d.multiply(resultMatrix, resultMatrix, scaleMatrix)

          this.x = x
          this.y = y
          this.rad = rad
          this.scaleX = scaleX,
          this.scaleY = scaleY
          this.matrix = resultMatrix
        }

        draw() {
          // 画一个矩形
          const vec1 = glMatrix.vec2.transformMat2d([], [0, 0], this.matrix)
          const vec2 = glMatrix.vec2.transformMat2d([], [50, 0], this.matrix)
          const vec3 = glMatrix.vec2.transformMat2d([], [50, 50], this.matrix)
          const vec4 = glMatrix.vec2.transformMat2d([], [0, 50], this.matrix)

          this.ctx.save()
          this.ctx.fillStyle = this.color

          this.ctx.beginPath()
          this.ctx.arc(vec1[0], vec1[1], this.radius, 0, 2 * Math.PI)
          this.ctx.fill()
          this.ctx.closePath()

          this.ctx.beginPath()
          this.ctx.arc(vec2[0], vec2[1], this.radius, 0, 2 * Math.PI)
          this.ctx.fill()
          this.ctx.closePath()

          this.ctx.beginPath()
          this.ctx.arc(vec3[0], vec3[1], this.radius, 0, 2 * Math.PI)
          this.ctx.fill()
          this.ctx.closePath()

          this.ctx.beginPath()
          this.ctx.arc(vec4[0], vec4[1], this.radius, 0, 2 * Math.PI)
          this.ctx.fill()
          this.ctx.closePath()

          this.ctx.restore()
        }
      }

      let vm = new Vue({
        el: "#app",
        data() {
          return {
            canvas: null,
            canvasWidth: 0,
            canvasHeight: 0,
            ctx: null,

            operateX: 500,
            operateY: 100,
            operateRad: 0,
            operateScaleX: 1,
            operateScaleY: 1,

            ball: null,
          }
        },
        computed: {
          angle() {
            return (360 * this.ball.rad) / (2 * Math.PI)
          },
        },
        mounted() {
          const {
            canvas,
            width: canvasWidth,
            height: canvasHeight,
          } = new KSize("canvas", {
            width: 500,
            height: 500,
          })
          this.canvas = canvas
          this.canvasWidth = canvasWidth
          this.canvasHeight = canvasHeight

          this.ctx = canvas.getContext("2d")
          this.ball = new Ball(this.ctx, { x: this.operateX, y: this.operateY })

          this.render()
        },
        methods: {
          render() {
            this.ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight)
            this.ball.draw()
            requestAnimationFrame(this.render)
          },

          handleXChange(e) {
            const percent = e.currentTarget.value / 100
            this.operateX = this.canvasWidth * percent

            this.ball.transform({ x: this.operateX })
          },
          handleYChange(e) {
            const percent = e.currentTarget.value / 100
            this.operateY = this.canvasWidth * percent

            this.ball.transform({ y: this.operateY })
          },
          handleRadChange(e) {
            const percent = e.currentTarget.value / 100
            this.operateRad = 2 * Math.PI * percent

            this.ball.transform({ rad: this.operateRad })
          },
          handleScaleXChange(e) {
            const percent = e.currentTarget.value / 100
            this.operateScaleX = percent * 4 + 1 // 1 ~ 5

            this.ball.transform({ scaleX: this.operateScaleX })
          },
          handleScaleYChange(e) {
            const percent = e.currentTarget.value / 100
            this.operateScaleY = percent * 4 + 1 // 1 ~ 5

            this.ball.transform({ scaleY: this.operateScaleY })
          },
        },
      })
    </script>
  </body>
</html>
