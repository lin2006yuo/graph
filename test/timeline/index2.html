<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="../size.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
    <title>Timeline</title>
    <style>
      .wrapper {
        display: flex;
      }
      .operator {
        margin-left: 20px;
      }
      .range-slider {
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
        width: 10rem;
        height: 0.25rem;
        outline: none;
        border-radius: 0.25rem;
        background-color: #000;
      }
      .range-slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 1.5rem;
        height: 1.5rem;
        background-color: #fff;
        border: 0.25rem solid #000;
        border-radius: 1rem;
        cursor: pointer;
      }

      .scroll-bar-wrapper {
        margin-bottom: 30px;
      }
      .scroll-bar {
        height: 4px;
        background: #000;
      }

      .slider {
        width: 500px;
        height: 20px;
        background-color: #666;
      }
    </style>
  </head>
  <body>
    <div id="app">
      <div class="wrapper">
        <div>
          <canvas id="canvas"></canvas>
          <div class="scroll-bar-wrapper">
            <div
              class="scroll-bar"
              :style="{width: scrollbarWidth + 'px', transform: `translateX(${scrollbarTransformX}px)`}"
            ></div>
          </div>
          <div class="slider-wrapper" id="slider-wrapper">
            <div class="slider"></div>
          </div>

          <h3>Canvas</h3>
          <div>width: {{canvasWidth}}</div>
          <div>height: {{canvasHeight}}</div>
          <div>scale: {{scale}}</div>
          <div>pxStart: {{pxStart}}</div>
          <div>fixedTStart: {{fixedTStart}}</div>
          <div>x: {{x}}</div>
        </div>

        <div class="operator">
          <h3>Bar</h3>
          <input @input="handleChange" type="range" min="0" max="100" :value="RangePercent" class="range-slider" />
        </div>
      </div>
    </div>

    <script>
      class WheelAccumulator {
        dx = 0;
        dy = 0;

        push(p) {
          this.dx += p.x;
          this.dy += p.y;
        }

        clear() {
          this.dx = 0;
          this.dy = 0;
        }
      }
      const SCROLLBAR_MIN_WIDTH = 100;
      let SCROLLBAR_MAX_WIDTH = 0;
      const wa = new WheelAccumulator();
      const TIME_MAP_DATA = [
        { largeScale: 7200000, smallScale: 480000, minRatio: 57142.84, maxRatio: 28571.42 },
        { largeScale: 3600000, smallScale: 240000, minRatio: 28571.42, maxRatio: 14285.71 },
        { largeScale: 1800000, smallScale: 120000, minRatio: 14285.71, maxRatio: 7142.85 },
        { largeScale: 900000, smallScale: 60000, minRatio: 7142.85, maxRatio: 2380.95 },
        { largeScale: 300000, smallScale: 30000, minRatio: 2380.95, maxRatio: 952.38 },
        { largeScale: 120000, smallScale: 12000, minRatio: 952.38, maxRatio: 466.19 },
        { largeScale: 60000, smallScale: 5000, minRatio: 476.19, maxRatio: 238.09 },
        { largeScale: 30000, smallScale: 2000, minRatio: 238.09, maxRatio: 119.04 },
        { largeScale: 15000, smallScale: 1000, minRatio: 119.04, maxRatio: 39.68 },
        { largeScale: 5000, smallScale: 500, minRatio: 39.68, maxRatio: 15.87 },
        { largeScale: 2000, smallScale: 200, minRatio: 15.87, maxRatio: 7.93 },
        { largeScale: 1000, smallScale: 200, minRatio: 7.93, maxRatio: 1.32 },
        { largeScale: 200, smallScale: 40, minRatio: 1.32, maxRatio: 1 },
      ];
      const getScaleText = (time, scale) => {
        const hours = addZero(Math.floor(time / (60 * 60 * 1000)));
        const minutes = addZero(Math.floor((time % (1000 * 60 * 60)) / (60 * 1000)));
        const seconds = addZero(Math.floor((time % (1000 * 60)) / 1000));
        const ms = addZero(time % 1000, 3);
        let res = [hours, minutes, seconds].join(':');
        if (hours === '00') {
          res = res.slice(3);
        }
        // ms 级别
        if (scale < 1000) {
          if (res === '00:00') {
            res = '';
          }
          res += `.${ms}`;
        }
        return res;
      };
      const ratios = TIME_MAP_DATA.map((o) => o.maxRatio).sort((a, b) => b - a);
      const minRatio = ratios[0];
      const maxRatio = ratios[ratios.length - 1];
      const calcP = (r) => Math.log(r / minRatio) / Math.log(maxRatio / minRatio);
      function addZero(num, digit = 2) {
        return num.toString().padStart(digit, '0');
      }
      function getTickStartEnd(start, tick, begin = true) {
        let mod = start | tick;
        let div = begin ? Math.floor(start / tick) : Math.ceil(start / tick);
        return mod > 0 ? div * tick : start;
      }
      const Keyboard = {
        command: false,
      };
      const IS_WINDOWS = /windows|win32|win64|wow32|wow64/gi.test(navigator.userAgent);
      const IS_MAC = /macintosh|macintel/gi.test(navigator.userAgent);
      function withCommand(ev) {
        if (IS_WINDOWS) {
          return ev.ctrlKey;
        } else if (IS_MAC) {
          return ev.metaKey;
        } else {
          return false;
        }
      }
      let vm = new Vue({
        el: '#app',
        data() {
          return {
            canvas: null,
            ctx: null,
            canvasWidth: 0,
            canvasHeight: 0,

            scrollbarWidth: 0,
            scrollbarTransformX: 0,

            start: 0,
            scale: 1,
            duration: 1200,
            RangePercent: 0,
            x: 0,
            pxStart: 0,
            fixedTStart: 0,
          };
        },
        computed: {
          maxScale() {
            return this.duration / this.canvasWidth;
          },
        },
        mounted() {
          let { canvas, width: canvasWidth, height: canvasHeight } = new KSize('canvas', {
            width: 50,
            height: 500,
          });
          this.canvas = canvas;
          this.ctx = this.canvas.getContext('2d');
          this.canvasWidth = canvasWidth;
          this.canvasHeight = canvasHeight;

          canvas.addEventListener('mousewheel', this.processMouseWheel.bind(this));
          window.addEventListener('keydown', this.processKeyDown.bind(this));
          window.addEventListener('keyup', this.processKeyUp.bind(this));

          const $sliderWrapper = document.getElementById('slider-wrapper');
          SCROLLBAR_MAX_WIDTH = $sliderWrapper.getBoundingClientRect().width;
          const contentMS = this.px2ms(this.canvasWidth);
          this.scrollbarWidth = (SCROLLBAR_MAX_WIDTH - 2) * (contentMS / this.duration);

          this.draw();
        },
        methods: {
          draw() {
            this.ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);
            this.ctx.save();
            this.drawCoord();
            this.ctx.restore();
          },
          handleChange(e) {
            let percent = e.target.value / 100;
            this.RangePercent = e.target.value;
            this.scale = Math.pow(this.maxScale / 1, percent) * 1;
            this.zoom(this.scale);
          },
          processKeyDown(e) {
            Keyboard.command = withCommand(e);
          },
          processKeyUp(e) {
            Keyboard.command = withCommand(e);
          },
          processMouseWheel(event) {
            event.preventDefault();

            // 缩放
            let delta = 0;
            delta = -event.deltaY / 1000;
            if (delta && Keyboard.command) {
              const zoomFriction = 0.4;
              let scale;
              if (delta < 0) {
                scale = 1 - delta / zoomFriction;
              } else {
                scale = 1 / (1 + delta / zoomFriction);
              }
              let res = this.scale * scale;
              if (res < 1) res = 1;
              if (res > this.maxScale) res = this.maxScale;
              this.scale = res;
              this.RangePercent = (Math.log(res / 1) / Math.log(this.maxScale / 1)) * 100;
              this.zoom(this.scale);
            }

            // 水平滑动
            if (!Keyboard.command) {
              wa.push({
                origin: event,
                x: event.deltaX,
                y: event.deltaY,
              });
              const { dx, dy } = wa;
              wa.clear();
              if (dx !== 0) {
                let offset = this.x + this.px2ms(dx);
                const barMS = this.px2ms(this.scrollbarWidth);
                const contentMS = this.px2ms(this.canvasWidth);
                if (offset < 0) offset = 0;
                if (offset + contentMS > this.duration) offset = this.duration - contentMS;
                this.x = offset;
                const px = this.ms2px(offset); // px
                this.scrollbarTransformX = (px * SCROLLBAR_MAX_WIDTH) / this.ms2px(this.duration);

                this.draw();
              }
            }
          },
          zoom(scale) {
            this.scale = scale;
            const contentMS = this.px2ms(this.canvasWidth);
            this.scrollbarWidth = (SCROLLBAR_MAX_WIDTH - 2) * (contentMS / this.duration);
            this.draw();
          },
          ms2px(ms) {
            return ms / this.scale;
          },
          px2ms(px) {
            return px * this.scale;
          },
          drawCoord() {
            const { ctx, canvasWidth, canvasHeight, ms2px, px2ms } = this;
            ctx.strokeStyle = 'black';
            // x轴
            ctx.beginPath();
            ctx.moveTo(0, canvasHeight / 2);
            ctx.lineTo(canvasWidth, canvasHeight / 2);
            ctx.stroke();
            const begin = this.x; // ms
            const end = px2ms(canvasWidth);

            const fontSize = 24;
            const marginLeft = 0;

            const scale = TIME_MAP_DATA.find((o) => o.maxRatio <= this.scale) || TIME_MAP_DATA[TIME_MAP_DATA.length - 1];

            const pxEnd = ms2px(this.duration);

            const fixedTStart = Math.ceil(begin / scale.smallScale) * scale.smallScale;
            const pxStart = ms2px(fixedTStart - begin);
            // const fixedTStart = Math.ceil(begin / scale.smallScale) * scale.smallScale;
            // const pxStart = ms2px(scale.smallScale - (begin % scale.smallScale));

            // 记录
            this.pxStart = pxStart;
            this.fixedTStart = fixedTStart;

            const step = ms2px(scale.smallScale);
            for (let x = pxStart, t = fixedTStart; x <= pxEnd; x += step, t += scale.smallScale) {
              ctx.beginPath();
              ctx.font = fontSize + 'px Helvetica';

              let lineHeight = 20;
              if (t % scale.largeScale === 0) {
                lineHeight = 40;
                const timeText = getScaleText(t, scale.largeScale);
                ctx.fillText(timeText, x - fontSize / 3, canvasHeight / 2 + fontSize);
              }
              ctx.moveTo(x, canvasHeight / 2);
              ctx.lineTo(x, canvasHeight / 2 - lineHeight);
              ctx.stroke();
            }
          },
        },
      });
    </script>
  </body>
</html>
