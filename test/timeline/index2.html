<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="../size.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
    <title>Timeline</title>
  </head>
  <body>
    <div id="app">
      <canvas id="canvas"></canvas>
      <h3>Canvas</h3>
      <div>width: {{canvasWidth}}</div>
      <div>height: {{canvasHeight}}</div>
      <div>scale: {{scale}}</div>
    </div>

    <script>
      const TickMap = (function () {
        function tick(unitNumber) {
          if(unitNumber === 'ms') {
            return [1, 2, 5].map((n) => n * 100)
          }
          return [1, 5, 15, 30, 60].map((n) => n * unitNumber)
        }
        return ['ms', 1000, 60000, 3600000].reduce((t, c) => {
          return [...t, ...tick(c)]
        }, [])
      })()
      console.log(TickMap)
      function addZero(num, digit = 2) {
        return num.toString().padStart(digit, "0")
      }
      function msTodTime(ms, tick) {
        const s = addZero(Math.floor((ms % (1000 * 60)) / 1000))
        const m = addZero(Math.floor((ms % (1000 * 60 * 60)) / (1000 * 60)))
        const h = addZero(Math.floor(ms / (1000 * 60 * 60)))
        const ss = addZero(ms % 1000, 3)
        let res = [h, m, s, ss].join(":")
        if (h === "00") {
          res = res.slice(3)
        }
        if (tick <= 500) {
          if (res === "00:00") {
            res = ""
            res += `.${ss}`
          }
        }
        return res
      }
      function getTick(begin, end) {
        const delta = end - begin
        const approxTick = delta / 6
        const index = TickMap.findIndex((n) => approxTick < n)
        return [TickMap[index], index]
      }
      function getTickStartEnd(start, tick, begin = true) {
        let mod = start | tick
        let div = begin ? Math.floor(start / tick) : Math.ceil(start / tick)
        return mod > 0 ? div * tick : start
      }
      let vm = new Vue({
        el: "#app",
        data() {
          return {
            canvas: null,
            ctx: null,
            canvasWidth: 0,
            canvasHeight: 0,

            start: 0,
            scale: 1,
          }
        },
        computed: {
          end() {
            return this.canvasWidth * this.scale
          },
          tick() {
            if (this.scale > 0.38) {
              return 50
            } else {
              return 20
            }
          },
        },
        mounted() {
          let { canvas, width: canvasWidth, height: canvasHeight } = new KSize(
            "canvas",
            {
              width: 500,
              height: 500,
            }
          )
          this.canvas = canvas
          this.ctx = this.canvas.getContext("2d")
          this.canvasWidth = canvasWidth
          this.canvasHeight = canvasHeight

          canvas.addEventListener("mousewheel", this.processMouseWheel)

          this.draw()
        },
        methods: {
          draw() {
            this.ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight)
            this.ctx.save()
            this.drawCoord()
            this.ctx.restore()
          },
          processMouseWheel(e) {
            e.preventDefault()
            if (e.wheelDelta > 0) {
              this.scale *= 1.05
            } else {
              let res = this.scale / 1.05
              if (res < 1) return
              this.scale = res
            }

            this.draw()
          },
          drawCoord() {
            const { ctx, canvasWidth, canvasHeight } = this
            ctx.strokeStyle = "black"
            // xè½´
            ctx.beginPath()
            ctx.moveTo(0, canvasHeight / 2)
            ctx.lineTo(canvasWidth, canvasHeight / 2)
            ctx.stroke()

            const begin = 0
            const end = 30000 / this.scale
            const [tick, index] = getTick(begin, end)
            const largeTick = tick[index + 1]
            const fontSize = 24
            const marginLeft = 0
            const step = (canvasWidth - marginLeft * 6) / (end - begin)
            let gap = 4
            let gapCount = 0
            for (let i = begin; i <= end; i += tick) {
              const x = i * step + marginLeft
              ctx.beginPath()
              ctx.moveTo(x, canvasHeight / 2)
              ctx.lineTo(x, canvasHeight / 2 - 20)
              ctx.font = fontSize + "px Helvetica"
              ctx.fillText(
                msTodTime(i, tick),
                x - fontSize / 3,
                canvasHeight / 2 + fontSize
              )
              ctx.stroke()

              const cur = i * step
              const next = (i + tick) * step
              const avg = (next - cur) / 10
              for (let n_i = cur; n_i <= next; n_i += avg) {
                ctx.beginPath()
                const x = n_i
                ctx.moveTo(x, canvasHeight / 2)
                ctx.lineTo(x, canvasHeight / 2 - 10)
                ctx.font = fontSize + "px Helvetica"
                ctx.stroke()
              }
            }
          },
        },
      })
    </script>
  </body>
</html>
