<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Mat</title>
    <script src="../hidpi-canvas.js"></script>
    <!-- <script src="./ball.js"></script> -->
    <script src="../Mouse.js"></script>
    <!-- <script src="./arrow.js"></script> -->
  </head>
  <body>
    <canvas width="400" height="400" style="border: 1px solid"></canvas>
    <script>
      var m3 = {
        translation: function (tx, ty) {
          // prettier-ignore
          return [
                  1, 0, 0,
                  0, 1, 0,
                  tx, ty, 1
                ]
        },

        rotation: function (angleInRadians) {
          var c = Math.cos(angleInRadians);
          var s = Math.sin(angleInRadians);
          // prettier-ignore
          return [
                  c, -s, 0,
                  s, c, 0,
                  0, 0, 1
                ]
        },

        scaling: function (sx, sy) {
          // prettier-ignore
          return [
                  sx, 0, 0,
                  0, sy, 0,
                  0, 0, 1
                ]
        },
        multiply: function (a, b) {
          var a00 = a[0 * 3 + 0];
          var a01 = a[0 * 3 + 1];
          var a02 = a[0 * 3 + 2];
          var a10 = a[1 * 3 + 0];
          var a11 = a[1 * 3 + 1];
          var a12 = a[1 * 3 + 2];
          var a20 = a[2 * 3 + 0];
          var a21 = a[2 * 3 + 1];
          var a22 = a[2 * 3 + 2];
          var b00 = b[0 * 3 + 0];
          var b01 = b[0 * 3 + 1];
          var b02 = b[0 * 3 + 2];
          var b10 = b[1 * 3 + 0];
          var b11 = b[1 * 3 + 1];
          var b12 = b[1 * 3 + 2];
          var b20 = b[2 * 3 + 0];
          var b21 = b[2 * 3 + 1];
          var b22 = b[2 * 3 + 2];
          return [
            b00 * a00 + b01 * a10 + b02 * a20,
            b00 * a01 + b01 * a11 + b02 * a21,
            b00 * a02 + b01 * a12 + b02 * a22,
            b10 * a00 + b11 * a10 + b12 * a20,
            b10 * a01 + b11 * a11 + b12 * a21,
            b10 * a02 + b11 * a12 + b12 * a22,
            b20 * a00 + b21 * a10 + b22 * a20,
            b20 * a01 + b21 * a11 + b22 * a21,
            b20 * a02 + b21 * a12 + b22 * a22,
          ];
        },

        multiplyPoint: function (matrix, point) {
          var x = point[0],
            y = point[1],
            z = point[2];

          var c1r1 = matrix[0],
            c2r1 = matrix[1],
            c3r1 = matrix[2],
            c1r2 = matrix[3],
            c2r2 = matrix[4],
            c3r2 = matrix[5],
            c1r3 = matrix[6],
            c2r3 = matrix[7],
            c3r3 = matrix[8];

          return [x * c1r1 + y * c1r2 + z * c1r3, x * c2r1 + y * c2r2 + z * c2r3, x * c3r1 + y * c3r2 + z * c3r3];
        },
      };

      class Dot {
        constructor(x, y, radius = 5, opt) {
          this.x = x;
          this.y = y;
          this.radius = radius;
          this.mouse = opt.mouse;
          this.lineWidth = 5;
          this.fillStyle = 'white';
        }
        get isOver() {
          return this.distance(this.mouse.x, this.mouse.y) < this.radius + this.lineWidth;
        }
        setPosition(opt) {
          Object.keys(opt).forEach((k) => {
            this[k] = opt[k];
          });
        }
        distance(x2, y2) {
          const { x: x1, y: y1 } = this;
          return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
        }
        draw(ctx) {
          ctx.save();
          if (this.isOver) {
            this.fillStyle = 'red';
          } else {
            this.fillStyle = 'white';
          }
          ctx.fillStyle = this.fillStyle;
          ctx.lineWidth = this.lineWidth;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
          ctx.stroke();
          ctx.fill();
          ctx.restore();
        }
      }

      class Rect {
        constructor(x = 0, y = 0, width, height, opt) {
          this.x = x;
          this.y = y;
          this.width = width;
          this.height = height;

          this.dot1 = new Dot(this.x, this.y, 5, opt);
          this.dot2 = new Dot(this.width + this.x, this.y, 5, opt);
          this.dot3 = new Dot(this.width + this.x, this.height + this.y, 5, opt);
          this.dot4 = new Dot(this.x, this.height + this.y, 5, opt);

          this.mouse = opt.mouse;

          this.translateX = 0;
          this.translateY = 0;
          this.scaleX = 1;
          this.scaleY = 1;
          this.angle = 0;

          this.isMouseDown = false;

          const mousedown = () => {
            this.isMouseDown = true;
          };

          const mouseup = () => {
            this.isMouseDown = false;
          };

          const mousemove = () => {
            if (this.isMouseDown) {
              // this.scaleX = this.mouse.x / this.dot4.x;
              // this.scaleY = this.mouse.y / this.dot4.y;
            }
          };

          window.addEventListener('mousedown', mousedown);
          window.addEventListener('mousemove', mousemove);
          window.addEventListener('mouseup', mouseup);
        }
        get rotation() {
          return [Math.sin((this.angle * Math.PI) / 180), Math.cos((this.angle * Math.PI) / 180)];
        }
        setPosition(opt) {
          Object.keys(opt).forEach((k) => {
            this[k] = opt[k];
          });
        }
        draw(ctx) {
          ctx.save();
          ctx.fillStyle = 'yellow';
          ctx.lineWidth = '5';
          ctx.lineJoin = 'round';
          ctx.beginPath();

          // 矩阵变换
          const mat_t = m3.translation(this.translateX, this.translateY);
          const mat_r = m3.rotation((Math.PI * this.angle) / 180);
          const mat_s = m3.scaling(this.scaleX, this.scaleY);

          let mat_e = m3.multiply(mat_r, mat_t);
          mat_e = m3.multiply(mat_e, mat_s);

          const d1 = m3.multiplyPoint(mat_e, [this.dot1.x, this.dot1.y, 1]);
          const d2 = m3.multiplyPoint(mat_e, [this.dot2.x, this.dot2.y, 1]);
          const d3 = m3.multiplyPoint(mat_e, [this.dot3.x, this.dot3.y, 1]);
          const d4 = m3.multiplyPoint(mat_e, [this.dot4.x, this.dot4.y, 1]);

          ctx.moveTo(d1[0], d1[1]);
          ctx.lineTo(d2[0], d2[1]);
          ctx.lineTo(d3[0], d3[1]);
          ctx.lineTo(d4[0], d4[1]);
          ctx.closePath();
          ctx.stroke();
          ctx.fill();
          ctx.restore();

          this.dot1.setPosition({ x: d1[0], y: d1[1] });
          this.dot1.draw(ctx);
          this.dot2.setPosition({ x: d2[0], y: d2[1] });
          this.dot2.draw(ctx);
          this.dot3.setPosition({ x: d3[0], y: d3[1] });
          this.dot3.draw(ctx);
          this.dot4.setPosition({ x: d4[0], y: d4[1] });
          this.dot4.draw(ctx);
        }
      }
    </script>
    <script>
      const canvas = document.querySelector('canvas');
      const ctx = canvas.getContext('2d');
      const mouse = utils.mouse(canvas);

      const rect = new Rect(0, 0, 100, 100, {
        mouse,
      });

      function drawFrame(t) {
        window.requestAnimationFrame(drawFrame);
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        rect.setPosition({
          angle: 0,
          translateX: 0,
          translateY: 0,
          scaleX: 1.001,
        });

        rect.draw(ctx);
      }
      drawFrame();
    </script>
  </body>
</html>
